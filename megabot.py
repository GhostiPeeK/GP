#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó ‚ïö‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  
‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

              üéÆ P2P –ì–ï–ô–ú–ò–ù–ì –ú–ê–†–ö–ï–¢–ü–õ–ï–ô–° + –ö–†–ò–ü–¢–û-–ë–ò–†–ñ–ê üéÆ
                          –°–¢–ê–ë–ò–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø
"""

import os
import sys
import json
import sqlite3
import logging
import asyncio
import random
import string
import uuid
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List

from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import (
    Message, CallbackQuery,
    InlineKeyboardMarkup, InlineKeyboardButton,
    ReplyKeyboardMarkup, KeyboardButton
)
from aiogram.client.bot import DefaultBotProperties
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage

# ============================================
# –¢–í–û–ò –î–ê–ù–ù–´–ï (–í–°–¢–ê–í–¨ –°–í–û–ò)
# ============================================

BOT_TOKEN = "8339352233:AAGixj9izEbOVKHvhpKeTd_4_Y2CP-f-ZhE"
ADMIN_ID = 2091630272

# ============================================
# –ù–ê–°–¢–†–û–ô–ö–ò –ü–õ–ê–¢–§–û–†–ú–´
# ============================================

COMMISSION = 1.0  # –ö–æ–º–∏—Å—Å–∏—è –±–æ—Ç–∞ (%)
ESCROW_TIME = 60  # –í—Ä–µ–º—è –Ω–∞ –æ–ø–ª–∞—Ç—É (–º–∏–Ω—É—Ç)
MIN_DEAL_AMOUNT = 100  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ (—Ä—É–±)
REFERRAL_BONUS = 10  # –ë–æ–Ω—É—Å —Ä–µ—Ñ–µ—Ä–µ—Ä—É (%)

# ============================================
# –ò–ì–†–´
# ============================================

GAMES = {
    'pubg': {'name': 'PUBG Mobile', 'currency': 'UC', 'icon': 'ü™ñ'},
    'brawl': {'name': 'Brawl Stars', 'currency': '–≥–µ–º—ã', 'icon': 'ü•ä'},
    'freefire': {'name': 'Free Fire', 'currency': '–∞–ª–º–∞–∑—ã', 'icon': 'üî•'},
    'steam': {'name': 'Steam', 'currency': '—Ä—É–±', 'icon': 'üéÆ'},
    'genshin': {'name': 'Genshin Impact', 'currency': '–∫—Ä–∏—Å—Ç–∞–ª–ª—ã', 'icon': '‚ú®'},
    'cod': {'name': 'Call of Duty', 'currency': 'CP', 'icon': 'üî´'},
    'roblox': {'name': 'Roblox', 'currency': 'Robux', 'icon': 'üé≤'},
    'fortnite': {'name': 'Fortnite', 'currency': 'V-bucks', 'icon': 'üõ°Ô∏è'}
}

# ============================================
# –ö–†–ò–ü–¢–û–í–ê–õ–Æ–¢–´
# ============================================

CRYPTO_CURRENCIES = {
    'USDT': {'name': 'Tether', 'icon': 'üíµ', 'network': 'TRC20'},
    'TON': {'name': 'Toncoin', 'icon': 'üíé', 'network': 'TON'},
    'BTC': {'name': 'Bitcoin', 'icon': '‚Çø', 'network': 'BTC'}
}

# ============================================
# –ü–õ–ê–¢–Å–ñ–ù–´–ï –ú–ï–¢–û–î–´
# ============================================

PAYMENT_METHODS = {
    'sbp': {'name': '–°–ë–ü', 'icon': 'üí≥'},
    'card': {'name': '–ö–∞—Ä—Ç–∞', 'icon': 'üí≥'},
    'yoomoney': {'name': '–ÆMoney', 'icon': 'üí∞'},
    'qiwi': {'name': 'Qiwi', 'icon': 'üì±'},
    'cash': {'name': '–ù–∞–ª–∏—á–Ω—ã–µ', 'icon': 'üíµ'}
}

# ============================================
# –°–û–°–¢–û–Ø–ù–ò–Ø FSM
# ============================================

class CreateOrder(StatesGroup):
    choosing_market = State()  # game –∏–ª–∏ crypto
    choosing_item = State()     # –∏–≥—Ä–∞ –∏–ª–∏ –≤–∞–ª—é—Ç–∞
    choosing_type = State()     # buy –∏–ª–∏ sell
    entering_amount = State()   # –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
    entering_price = State()    # —Ü–µ–Ω–∞
    entering_comment = State()  # –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
    choosing_payment = State()  # —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã
    confirm = State()           # –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ

class TradeProcess(StatesGroup):
    waiting_payment = State()
    waiting_confirmation = State()
    waiting_review = State()

# ============================================
# –ë–ê–ó–ê –î–ê–ù–ù–´–• (–ü–†–û–°–¢–ê–Ø –ò –†–ê–ë–û–ß–ê–Ø)
# ============================================

class Database:
    def __init__(self, db_name="p2p_bot.db"):
        self.db_name = db_name
        self.init_db()
    
    def get_connection(self):
        return sqlite3.connect(self.db_name)
    
    def init_db(self):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY,
                username TEXT,
                first_name TEXT,
                registered_at TIMESTAMP,
                referrer_id INTEGER DEFAULT NULL,
                referral_code TEXT UNIQUE,
                rating REAL DEFAULT 5.0,
                deals INTEGER DEFAULT 0,
                balance REAL DEFAULT 0
            )
        ''')
        
        # –û—Ä–¥–µ—Ä–∞
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS orders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                market_type TEXT,
                item_id TEXT,
                item_name TEXT,
                order_type TEXT,
                amount REAL,
                price REAL,
                total REAL,
                comment TEXT,
                payment_method TEXT,
                status TEXT DEFAULT 'active',
                created_at TIMESTAMP
            )
        ''')
        
        # –°–¥–µ–ª–∫–∏
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS trades (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                order_id INTEGER,
                seller_id INTEGER,
                buyer_id INTEGER,
                amount REAL,
                total REAL,
                commission REAL,
                status TEXT DEFAULT 'pending',
                created_at TIMESTAMP,
                expires_at TIMESTAMP
            )
        ''')
        
        conn.commit()
        conn.close()
    
    # ========== –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–ò ==========
    
    def add_user(self, user_id, username, first_name, referrer_code=None):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        ref_code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
        
        referrer_id = None
        if referrer_code:
            cursor.execute('SELECT user_id FROM users WHERE referral_code = ?', (referrer_code,))
            res = cursor.fetchone()
            if res:
                referrer_id = res[0]
        
        cursor.execute('''
            INSERT OR REPLACE INTO users 
            (user_id, username, first_name, registered_at, referrer_id, referral_code)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (user_id, username, first_name, datetime.now(), referrer_id, ref_code))
        
        conn.commit()
        conn.close()
        return ref_code
    
    def get_user(self, user_id):
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))
        row = cursor.fetchone()
        conn.close()
        
        if row:
            return {
                'user_id': row[0],
                'username': row[1],
                'first_name': row[2],
                'registered_at': row[3],
                'referrer_id': row[4],
                'referral_code': row[5],
                'rating': row[6],
                'deals': row[7],
                'balance': row[8]
            }
        return None
    
    # ========== –û–†–î–ï–†–ê ==========
    
    def create_order(self, user_id, market_type, item_id, item_name, order_type, 
                    amount, price, comment, payment_method):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        total = amount * price
        
        cursor.execute('''
            INSERT INTO orders 
            (user_id, market_type, item_id, item_name, order_type, amount, price, total, comment, payment_method, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (user_id, market_type, item_id, item_name, order_type, amount, price, total, 
              comment, payment_method, datetime.now()))
        
        order_id = cursor.lastrowid
        conn.commit()
        conn.close()
        return order_id
    
    def get_active_orders(self, market_type=None, item_id=None, limit=20):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        query = 'SELECT * FROM orders WHERE status = "active"'
        params = []
        
        if market_type:
            query += ' AND market_type = ?'
            params.append(market_type)
        
        if item_id:
            query += ' AND item_id = ?'
            params.append(item_id)
        
        query += ' ORDER BY created_at DESC LIMIT ?'
        params.append(limit)
        
        cursor.execute(query, params)
        rows = cursor.fetchall()
        conn.close()
        
        orders = []
        for row in rows:
            orders.append({
                'id': row[0],
                'user_id': row[1],
                'market_type': row[2],
                'item_id': row[3],
                'item_name': row[4],
                'order_type': row[5],
                'amount': row[6],
                'price': row[7],
                'total': row[8],
                'comment': row[9],
                'payment_method': row[10],
                'status': row[11],
                'created_at': row[12]
            })
        return orders
    
    def get_order(self, order_id):
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM orders WHERE id = ?', (order_id,))
        row = cursor.fetchone()
        conn.close()
        
        if row:
            return {
                'id': row[0],
                'user_id': row[1],
                'market_type': row[2],
                'item_id': row[3],
                'item_name': row[4],
                'order_type': row[5],
                'amount': row[6],
                'price': row[7],
                'total': row[8],
                'comment': row[9],
                'payment_method': row[10],
                'status': row[11],
                'created_at': row[12]
            }
        return None
    
    def close_order(self, order_id):
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute('UPDATE orders SET status = "completed" WHERE id = ?', (order_id,))
        conn.commit()
        conn.close()
    
    # ========== –°–î–ï–õ–ö–ò ==========
    
    def create_trade(self, order_id, buyer_id, amount):
        conn = self.get_connection()
        cursor = conn.cursor()
        
        order = self.get_order(order_id)
        if not order:
            conn.close()
            return None
        
        total = amount * order['price']
        commission = total * (COMMISSION / 100)
        
        cursor.execute('''
            INSERT INTO trades 
            (order_id, seller_id, buyer_id, amount, total, commission, created_at, expires_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (order_id, order['user_id'], buyer_id, amount, total, commission, 
              datetime.now(), datetime.now() + timedelta(minutes=ESCROW_TIME)))
        
        trade_id = cursor.lastrowid
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ä–¥–µ—Ä
        new_amount = order['amount'] - amount
        if new_amount <= 0:
            cursor.execute('UPDATE orders SET status = "completed" WHERE id = ?', (order_id,))
        else:
            cursor.execute('UPDATE orders SET amount = ? WHERE id = ?', (new_amount, order_id))
        
        conn.commit()
        conn.close()
        return trade_id
    
    def get_trade(self, trade_id):
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM trades WHERE id = ?', (trade_id,))
        row = cursor.fetchone()
        conn.close()
        
        if row:
            return {
                'id': row[0],
                'order_id': row[1],
                'seller_id': row[2],
                'buyer_id': row[3],
                'amount': row[4],
                'total': row[5],
                'commission': row[6],
                'status': row[7],
                'created_at': row[8],
                'expires_at': row[9]
            }
        return None
    
    def complete_trade(self, trade_id):
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute('UPDATE trades SET status = "completed" WHERE id = ?', (trade_id,))
        
        # –ù–∞—á–∏—Å–ª—è–µ–º –∫–æ–º–∏—Å—Å–∏—é –∞–¥–º–∏–Ω—É
        trade = self.get_trade(trade_id)
        if trade:
            cursor.execute('UPDATE users SET balance = balance + ? WHERE user_id = ?', 
                          (trade['commission'], ADMIN_ID))
        
        conn.commit()
        conn.close()
    
    def get_user_trades(self, user_id):
        conn = self.get_connection()
        cursor = conn.cursor()
        cursor.execute('''
            SELECT * FROM trades 
            WHERE seller_id = ? OR buyer_id = ?
            ORDER BY created_at DESC LIMIT 10
        ''', (user_id, user_id))
        rows = cursor.fetchall()
        conn.close()
        
        trades = []
        for row in rows:
            trades.append({
                'id': row[0],
                'order_id': row[1],
                'seller_id': row[2],
                'buyer_id': row[3],
                'amount': row[4],
                'total': row[5],
                'commission': row[6],
                'status': row[7],
                'created_at': row[8],
                'expires_at': row[9]
            })
        return trades

db = Database()

# ============================================
# –ö–õ–ê–í–ò–ê–¢–£–†–´ (–ü–†–û–°–¢–´–ï –ò –ü–û–ù–Ø–¢–ù–´–ï)
# ============================================

def main_keyboard():
    builder = ReplyKeyboardBuilder()
    buttons = [
        KeyboardButton(text="üéÆ –ò–≥—Ä—ã"),
        KeyboardButton(text="üí∞ –ö—Ä–∏–ø—Ç–∞"),
        KeyboardButton(text="üë§ –ü—Ä–æ—Ñ–∏–ª—å"),
        KeyboardButton(text="üìû –ü–æ–º–æ—â—å")
    ]
    builder.add(*buttons)
    builder.adjust(2, 2)
    return builder.as_markup(resize_keyboard=True)

def games_keyboard():
    builder = InlineKeyboardBuilder()
    for game_id, game in GAMES.items():
        builder.button(text=f"{game['icon']} {game['name']}", callback_data=f"game_{game_id}")
    builder.adjust(2)
    builder.row(InlineKeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –æ—Ä–¥–µ—Ä", callback_data="create_game_order"))
    builder.row(InlineKeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu"))
    return builder.as_markup()

def crypto_keyboard():
    builder = InlineKeyboardBuilder()
    for curr_id, curr in CRYPTO_CURRENCIES.items():
        builder.button(text=f"{curr['icon']} {curr_id}", callback_data=f"crypto_{curr_id}")
    builder.adjust(2)
    builder.row(InlineKeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –æ—Ä–¥–µ—Ä", callback_data="create_crypto_order"))
    builder.row(InlineKeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu"))
    return builder.as_markup()

def order_type_keyboard():
    builder = InlineKeyboardBuilder()
    builder.button(text="üìà –ö—É–ø–∏—Ç—å", callback_data="type_buy")
    builder.button(text="üìâ –ü—Ä–æ–¥–∞—Ç—å", callback_data="type_sell")
    builder.adjust(2)
    builder.row(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="back"))
    return builder.as_markup()

def payment_keyboard():
    builder = InlineKeyboardBuilder()
    for pid, pm in PAYMENT_METHODS.items():
        builder.button(text=f"{pm['icon']} {pm['name']}", callback_data=f"payment_{pid}")
    builder.adjust(2)
    builder.row(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="back"))
    return builder.as_markup()

def back_keyboard():
    builder = InlineKeyboardBuilder()
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="back")
    builder.button(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")
    builder.adjust(2)
    return builder.as_markup()

def profile_keyboard():
    builder = InlineKeyboardBuilder()
    builder.button(text="üìä –ú–æ–∏ —Å–¥–µ–ª–∫–∏", callback_data="my_trades")
    builder.button(text="üí∞ –ë–∞–ª–∞–Ω—Å", callback_data="balance")
    builder.button(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")
    builder.adjust(2, 1)
    return builder.as_markup()

# ============================================
# –ë–û–¢
# ============================================

storage = MemoryStorage()
bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
dp = Dispatcher(storage=storage)

# ============================================
# –°–¢–ê–†–¢
# ============================================

@dp.message(Command("start"))
async def cmd_start(message: Message):
    user = message.from_user
    args = message.text.split()
    ref_code = args[1] if len(args) > 1 else None
    
    db.add_user(user.id, user.username, user.first_name, ref_code)
    
    await message.answer(
        f"üëã <b>–ü—Ä–∏–≤–µ—Ç, {user.first_name}!</b>\n\n"
        f"üéÆ –ó–¥–µ—Å—å —Ç—ã –º–æ–∂–µ—à—å:\n"
        f"‚Ä¢ –ü–æ–∫—É–ø–∞—Ç—å –∏ –ø—Ä–æ–¥–∞–≤–∞—Ç—å –∏–≥—Ä–æ–≤—É—é –≤–∞–ª—é—Ç—É\n"
        f"‚Ä¢ –¢–æ—Ä–≥–æ–≤–∞—Ç—å –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–æ–π P2P\n"
        f"‚Ä¢ –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ —Å–¥–µ–ª–∫–∏ —á–µ—Ä–µ–∑ –≥–∞—Ä–∞–Ω—Ç–∞\n\n"
        f"üëá –í—ã–±–µ—Ä–∏ —Ä–∞–∑–¥–µ–ª:",
        reply_markup=main_keyboard()
    )

# ============================================
# –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ
# ============================================

@dp.message(lambda m: m.text == "üéÆ –ò–≥—Ä—ã")
async def games_section(message: Message):
    await message.answer("üéÆ <b>–í—ã–±–µ—Ä–∏ –∏–≥—Ä—É:</b>", reply_markup=games_keyboard())

@dp.message(lambda m: m.text == "üí∞ –ö—Ä–∏–ø—Ç–∞")
async def crypto_section(message: Message):
    await message.answer("üí∞ <b>–í—ã–±–µ—Ä–∏ –≤–∞–ª—é—Ç—É:</b>", reply_markup=crypto_keyboard())

@dp.message(lambda m: m.text == "üë§ –ü—Ä–æ—Ñ–∏–ª—å")
async def profile_section(message: Message):
    user = db.get_user(message.from_user.id)
    if user:
        text = (
            f"üë§ <b>–¢–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å</b>\n\n"
            f"üìä –°–¥–µ–ª–æ–∫: {user['deals']}\n"
            f"‚≠ê –†–µ–π—Ç–∏–Ω–≥: {user['rating']}\n"
            f"üí∞ –ë–∞–ª–∞–Ω—Å: {user['balance']} ‚ÇΩ\n"
        )
        await message.answer(text, reply_markup=profile_keyboard())

@dp.message(lambda m: m.text == "üìû –ü–æ–º–æ—â—å")
async def help_section(message: Message):
    text = (
        "üìû <b>–ü–æ–º–æ—â—å</b>\n\n"
        "1. –ù–∞–π–¥–∏ –æ—Ä–¥–µ—Ä\n"
        "2. –ù–∞–∂–º–∏ ¬´–ö—É–ø–∏—Ç—å¬ª\n"
        "3. –í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ\n"
        "4. –û–ø–ª–∞—Ç–∏ –ø—Ä–æ–¥–∞–≤—Ü—É\n"
        "5. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏ –ø–æ–ª—É—á–µ–Ω–∏–µ\n\n"
        f"‚è± –í—Ä–µ–º—è –Ω–∞ –æ–ø–ª–∞—Ç—É: {ESCROW_TIME} –º–∏–Ω—É—Ç\n"
        f"üí∞ –ö–æ–º–∏—Å—Å–∏—è: {COMMISSION}%\n\n"
        "‚ùì –í–æ–ø—Ä–æ—Å—ã: @admin"
    )
    await message.answer(text, reply_markup=back_keyboard())

# ============================================
# –ù–ê–í–ò–ì–ê–¶–ò–Ø
# ============================================

@dp.callback_query(lambda c: c.data == "main_menu")
async def main_menu_callback(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.answer(
        "üè† <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>",
        reply_markup=main_keyboard()
    )
    await callback.answer()

@dp.callback_query(lambda c: c.data == "back")
async def back_callback(callback: CallbackQuery, state: FSMContext):
    current_state = await state.get_state()
    
    if current_state:
        await state.clear()
        await callback.message.edit_text(
            "üéÆ <b>–í—ã–±–µ—Ä–∏ –∏–≥—Ä—É:</b>",
            reply_markup=games_keyboard()
        )
    else:
        await callback.message.edit_text(
            "üéÆ <b>–í—ã–±–µ—Ä–∏ –∏–≥—Ä—É:</b>",
            reply_markup=games_keyboard()
        )
    
    await callback.answer()

# ============================================
# –ü–†–û–°–ú–û–¢–† –û–†–î–ï–†–û–í (–ò–ì–†–´)
# ============================================

@dp.callback_query(lambda c: c.data.startswith('game_'))
async def show_game_orders(callback: CallbackQuery):
    game_id = callback.data.replace('game_', '')
    game = GAMES[game_id]
    
    orders = db.get_active_orders(market_type='game', item_id=game_id)
    
    if not orders:
        await callback.message.edit_text(
            f"{game['icon']} <b>{game['name']}</b>\n\n"
            f"–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤.\n"
            f"–°–æ–∑–¥–∞–π –ø–µ—Ä–≤—ã–π! üöÄ",
            reply_markup=back_keyboard()
        )
        await callback.answer()
        return
    
    text = f"{game['icon']} <b>{game['name']} - –æ—Ä–¥–µ—Ä–∞:</b>\n\n"
    
    builder = InlineKeyboardBuilder()
    
    for order in orders[:5]:
        emoji = "üìà" if order['order_type'] == 'sell' else "üìâ"
        text += f"{emoji} {order['amount']:.0f} {game['currency']} √ó {order['price']}‚ÇΩ = {order['total']:.0f}‚ÇΩ\n"
        
        builder.button(
            text=f"{emoji} {order['amount']:.0f} {game['currency']}",
            callback_data=f"view_order_{order['id']}"
        )
    
    builder.adjust(2)
    builder.row(InlineKeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –æ—Ä–¥–µ—Ä", callback_data=f"create_game_{game_id}"))
    builder.row(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="back"))
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup())
    await callback.answer()

# ============================================
# –ü–†–û–°–ú–û–¢–† –û–†–î–ï–†–û–í (–ö–†–ò–ü–¢–ê)
# ============================================

@dp.callback_query(lambda c: c.data.startswith('crypto_'))
async def show_crypto_orders(callback: CallbackQuery):
    curr_id = callback.data.replace('crypto_', '')
    currency = CRYPTO_CURRENCIES[curr_id]
    
    orders = db.get_active_orders(market_type='crypto', item_id=curr_id)
    
    if not orders:
        await callback.message.edit_text(
            f"{currency['icon']} <b>{curr_id}</b>\n\n"
            f"–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤.\n"
            f"–°–æ–∑–¥–∞–π –ø–µ—Ä–≤—ã–π! üöÄ",
            reply_markup=back_keyboard()
        )
        await callback.answer()
        return
    
    text = f"{currency['icon']} <b>{curr_id} - –æ—Ä–¥–µ—Ä–∞:</b>\n\n"
    
    builder = InlineKeyboardBuilder()
    
    for order in orders[:5]:
        emoji = "üìà" if order['order_type'] == 'sell' else "üìâ"
        text += f"{emoji} {order['amount']} {curr_id} √ó {order['price']}‚ÇΩ = {order['total']:.0f}‚ÇΩ\n"
        
        builder.button(
            text=f"{emoji} {order['amount']} {curr_id}",
            callback_data=f"view_order_{order['id']}"
        )
    
    builder.adjust(2)
    builder.row(InlineKeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –æ—Ä–¥–µ—Ä", callback_data=f"create_crypto_{curr_id}"))
    builder.row(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="back"))
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup())
    await callback.answer()

# ============================================
# –ü–†–û–°–ú–û–¢–† –û–†–î–ï–†–ê
# ============================================

@dp.callback_query(lambda c: c.data.startswith('view_order_'))
async def view_order(callback: CallbackQuery):
    order_id = int(callback.data.replace('view_order_', ''))
    order = db.get_order(order_id)
    
    if not order:
        await callback.answer("‚ùå –û—Ä–¥–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return
    
    if order['market_type'] == 'game':
        game = GAMES[order['item_id']]
        icon = game['icon']
        currency = game['currency']
    else:
        currency = CRYPTO_CURRENCIES[order['item_id']]
        icon = currency['icon']
        currency = order['item_id']
    
    text = (
        f"{icon} <b>{order['item_name']}</b>\n"
        f"{'üìà –ü–†–û–î–ê–ñ–ê' if order['order_type'] == 'sell' else 'üìâ –ü–û–ö–£–ü–ö–ê'}\n\n"
        
        f"üí∞ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {order['amount']} {currency}\n"
        f"üíµ –¶–µ–Ω–∞: {order['price']} ‚ÇΩ\n"
        f"üíé –°—É–º–º–∞: {order['total']} ‚ÇΩ\n\n"
    )
    
    if order['comment']:
        text += f"üìù {order['comment']}\n\n"
    
    text += f"üïê –°–æ–∑–¥–∞–Ω: {order['created_at'][:16]}"
    
    builder = InlineKeyboardBuilder()
    
    if order['order_type'] == 'sell':
        builder.button(text="üíé –ö—É–ø–∏—Ç—å", callback_data=f"buy_{order_id}")
    else:
        builder.button(text="üíé –ü—Ä–æ–¥–∞—Ç—å", callback_data=f"sell_{order_id}")
    
    builder.button(text="‚≠ê –í –∏–∑–±—Ä–∞–Ω–Ω–æ–µ", callback_data=f"fav_{order_id}")
    builder.row(InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data=f"{order['market_type']}_{order['item_id']}"))
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup())
    await callback.answer()

# ============================================
# –°–û–ó–î–ê–ù–ò–ï –û–†–î–ï–†–ê (–ò–ì–†–´)
# ============================================

@dp.callback_query(lambda c: c.data.startswith('create_game_'))
async def create_game_order_start(callback: CallbackQuery, state: FSMContext):
    game_id = callback.data.replace('create_game_', '')
    game = GAMES[game_id]
    
    await state.update_data(market_type='game', item_id=game_id, item_name=game['name'])
    await state.set_state(CreateOrder.choosing_type)
    
    await callback.message.edit_text(
        f"{game['icon']} <b>{game['name']}</b>\n\n"
        f"–¢—ã —Ö–æ—á–µ—à—å –∫—É–ø–∏—Ç—å –∏–ª–∏ –ø—Ä–æ–¥–∞—Ç—å?",
        reply_markup=order_type_keyboard()
    )
    await callback.answer()

@dp.callback_query(CreateOrder.choosing_type, lambda c: c.data.startswith('type_'))
async def create_order_type(callback: CallbackQuery, state: FSMContext):
    order_type = callback.data.replace('type_', '')
    
    await state.update_data(order_type=order_type)
    await state.set_state(CreateOrder.entering_amount)
    
    await callback.message.edit_text(
        f"üí∞ <b>–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ:</b>\n\n"
        f"–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞: {MIN_DEAL_AMOUNT} ‚ÇΩ"
    )
    await callback.answer()

@dp.message(CreateOrder.entering_amount)
async def create_order_amount(message: Message, state: FSMContext):
    try:
        amount = float(message.text)
        if amount <= 0:
            raise ValueError
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ –±–æ–ª—å—à–µ 0")
        return
    
    await state.update_data(amount=amount)
    await state.set_state(CreateOrder.entering_price)
    
    await message.answer(
        f"üíµ <b>–í–≤–µ–¥–∏ —Ü–µ–Ω—É –∑–∞ –µ–¥–∏–Ω–∏—Ü—É (–≤ ‚ÇΩ):</b>"
    )

@dp.message(CreateOrder.entering_price)
async def create_order_price(message: Message, state: FSMContext):
    try:
        price = float(message.text)
        if price <= 0:
            raise ValueError
    except:
        await message.answer("‚ùå –í–≤–µ–¥–∏ —á–∏—Å–ª–æ –±–æ–ª—å—à–µ 0")
        return
    
    data = await state.get_data()
    total = data['amount'] * price
    
    if total < MIN_DEAL_AMOUNT:
        await message.answer(f"‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ —Å–¥–µ–ª–∫–∏ {MIN_DEAL_AMOUNT} ‚ÇΩ. –£–≤–µ–ª–∏—á—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–ª–∏ —Ü–µ–Ω—É.")
        return
    
    await state.update_data(price=price)
    await state.set_state(CreateOrder.entering_comment)
    
    await message.answer(
        f"üìù <b>–î–æ–±–∞–≤—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π (–∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å ¬´-¬ª —á—Ç–æ–±—ã –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å):</b>"
    )

@dp.message(CreateOrder.entering_comment)
async def create_order_comment(message: Message, state: FSMContext):
    comment = message.text if message.text != '-' else ''
    
    await state.update_data(comment=comment)
    await state.set_state(CreateOrder.choosing_payment)
    
    await message.answer(
        f"üí≥ <b>–í—ã–±–µ—Ä–∏ —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã:</b>",
        reply_markup=payment_keyboard()
    )

@dp.callback_query(CreateOrder.choosing_payment, lambda c: c.data.startswith('payment_'))
async def create_order_payment(callback: CallbackQuery, state: FSMContext):
    payment = callback.data.replace('payment_', '')
    
    await state.update_data(payment_method=payment)
    await state.set_state(CreateOrder.confirm)
    
    data = await state.get_data()
    total = data['amount'] * data['price']
    
    if data['market_type'] == 'game':
        game = GAMES[data['item_id']]
        icon = game['icon']
        name = game['name']
        currency = game['currency']
    else:
        currency = CRYPTO_CURRENCIES[data['item_id']]
        icon = currency['icon']
        name = data['item_id']
        currency = data['item_id']
    
    text = (
        f"{icon} <b>–ü—Ä–æ–≤–µ—Ä—å –¥–∞–Ω–Ω—ã–µ:</b>\n\n"
        f"–¢–∏–ø: {'üìà –ü—Ä–æ–¥–∞–∂–∞' if data['order_type'] == 'sell' else 'üìâ –ü–æ–∫—É–ø–∫–∞'}\n"
        f"–¢–æ–≤–∞—Ä: {name}\n"
        f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {data['amount']} {currency}\n"
        f"–¶–µ–Ω–∞: {data['price']} ‚ÇΩ\n"
        f"–°—É–º–º–∞: {total} ‚ÇΩ\n"
        f"–û–ø–ª–∞—Ç–∞: {PAYMENT_METHODS[data['payment_method']]['name']}\n"
    )
    
    if data['comment']:
        text += f"–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: {data['comment']}\n"
    
    text += f"\n‚úÖ –í—Å—ë –≤–µ—Ä–Ω–æ?"
    
    builder = InlineKeyboardBuilder()
    builder.button(text="‚úÖ –î–∞, —Å–æ–∑–¥–∞—Ç—å", callback_data="confirm_order")
    builder.button(text="‚ùå –ù–µ—Ç, –∑–∞–Ω–æ–≤–æ", callback_data="restart")
    builder.adjust(2)
    
    await callback.message.edit_text(text, reply_markup=builder.as_markup())
    await callback.answer()

@dp.callback_query(CreateOrder.confirm, lambda c: c.data == "confirm_order")
async def confirm_order(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    
    order_id = db.create_order(
        user_id=callback.from_user.id,
        market_type=data['market_type'],
        item_id=data['item_id'],
        item_name=data['item_name'],
        order_type=data['order_type'],
        amount=data['amount'],
        price=data['price'],
        comment=data['comment'],
        payment_method=data['payment_method']
    )
    
    await state.clear()
    
    await callback.message.edit_text(
        f"‚úÖ <b>–û—Ä–¥–µ—Ä —Å–æ–∑–¥–∞–Ω!</b>\n\n"
        f"ID: {order_id}\n"
        f"–¢—ã –º–æ–∂–µ—à—å –Ω–∞–π—Ç–∏ –µ–≥–æ –≤ —Å–ø–∏—Å–∫–µ –æ—Ä–¥–µ—Ä–æ–≤.",
        reply_markup=back_keyboard()
    )
    await callback.answer()

# ============================================
# –ü–û–ö–£–ü–ö–ê
# ============================================

@dp.callback_query(lambda c: c.data.startswith('buy_'))
async def buy_order(callback: CallbackQuery, state: FSMContext):
    order_id = int(callback.data.replace('buy_', ''))
    order = db.get_order(order_id)
    
    if not order or order['status'] != 'active':
        await callback.answer("‚ùå –û—Ä–¥–µ—Ä —É–∂–µ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", show_alert=True)
        return
    
    await state.update_data(order_id=order_id)
    
    await callback.message.edit_text(
        f"üí∞ <b>–í–≤–µ–¥–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ:</b>\n\n"
        f"–î–æ—Å—Ç—É–ø–Ω–æ: {order['amount']}\n"
        f"–¶–µ–Ω–∞: {order['price']} ‚ÇΩ",
        reply_markup=back_keyboard()
    )
    await callback.answer()

# ============================================
# –ü–†–û–§–ò–õ–¨
# ============================================

@dp.callback_query(lambda c: c.data == "my_trades")
async def my_trades(callback: CallbackQuery):
    trades = db.get_user_trades(callback.from_user.id)
    
    if not trades:
        await callback.message.edit_text(
            "üìä <b>–ú–æ–∏ —Å–¥–µ–ª–∫–∏</b>\n\n"
            "–£ —Ç–µ–±—è –ø–æ–∫–∞ –Ω–µ—Ç —Å–¥–µ–ª–æ–∫.",
            reply_markup=back_keyboard()
        )
        await callback.answer()
        return
    
    text = "üìä <b>–ú–æ–∏ —Å–¥–µ–ª–∫–∏:</b>\n\n"
    for trade in trades:
        status = "‚úÖ" if trade['status'] == 'completed' else "‚è≥"
        text += f"{status} {trade['total']} ‚ÇΩ - {trade['created_at'][:16]}\n"
    
    await callback.message.edit_text(text, reply_markup=back_keyboard())
    await callback.answer()

@dp.callback_query(lambda c: c.data == "balance")
async def show_balance(callback: CallbackQuery):
    user = db.get_user(callback.from_user.id)
    await callback.message.edit_text(
        f"üí∞ <b>–¢–≤–æ–π –±–∞–ª–∞–Ω—Å:</b>\n\n"
        f"{user['balance']} ‚ÇΩ",
        reply_markup=back_keyboard()
    )
    await callback.answer()

# ============================================
# –ó–ê–ü–£–°–ö
# ============================================

async def main():
    print("\n" + "="*50)
    print("üî• P2P –ë–û–¢ –ó–ê–ü–£–°–ö–ê–ï–¢–°–Ø...")
    print("="*50)
    
    me = await bot.get_me()
    print(f"‚úÖ –ë–æ—Ç: @{me.username}")
    print(f"üëë –ê–¥–º–∏–Ω: {ADMIN_ID}")
    print("="*50 + "\n")
    
    await bot.send_message(ADMIN_ID, "üöÄ <b>–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!</b>")
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())
